export const TITLE = 'Games';

export const BODY = `Yes, these are simple board games. When you take a board game, break it down into its individual component parts, find the similarities and generalizations between all board games, and isolate what makes each game unique, you can take this simple concept and generate a group of objects that you can use to easily build any board style game using Object Oriented Programming concepts. These games show object composition & interaction for the front and back end business logic, REST API, and websockets. The business logic is built upon a few fundamental classes: a Space class and an Avatar class. The 2 base classes are the foundation for the board and game-play. The Space class contains an array of Avatars currently occupied in the Space and each Avatar has a reference to which space it occupies with a location property. Next comes the Board and Player classes, Each Player has 1 Avatar and each Board is composed of many Spaces. By separating the board from spaces you can pass any function to the Board class in order to assemble the spaces for the requirements for the game rules. The Board class returns the game board as a doubly linked list. The Player holds all persistent and game dependent data for the current person playing. The Player can have one Avatar for a selected game. A specific game instance lives in a generic Game class along with other information pertinent to the game-play. The GameBuilder is a builder pattern used to set a game instance generator with necessary metadata, actions (as Command objects in multiple Chain of Responsibility patterns), and returns a BuiltGame. All BuiltGame objects are stored in an array to be consumed by the API that serves the business logic results to the client. The actions are built with dynamic endpoints. The REST-API request response life-cycle starts by building a Context object that is passed through the Chain Of Responsibility specific to each game and processes necessary actions. This provides constant time lookup and execution of actions not matter how many actions are defined. By following this pattern, any board style game can be built with DRY principles, no need to build endpoints specific to each game, and maximum code reuse-ability, and can be deployed easily over any JavaScript server runtime.`;
